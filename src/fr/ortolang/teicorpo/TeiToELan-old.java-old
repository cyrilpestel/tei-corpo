package fr.ortolang.tools.imports;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Map;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class TeiToElan extends TeiConverter {

	//Extension du fichier de sortie: .eaf
	final static String EXT = ".eaf";

	//Document elan
	Document elanDoc;
	//Element ANNOTATION_DOCUMENT: racine du document Elan)
	Element annot_doc;
	//Représentaion du document TEI
	File teiFile;

	//Liste des informations sur les tiers
	ArrayList<TierInfo> tierInfos;

	//Liste des types linguistiques
	ArrayList<Element> lgqTypes;

	//Constructeur à partir du nom du fichier TEI et du nom du fichier de sortie au format Elan
	public TeiToElan(String inputName, String outputName) {
		super(inputName, outputName);
	}

	//Ecriture du fichier de sortie
	@Override
	public void outputWriter() {
		elanDoc = null;
		DocumentBuilderFactory factory = null;
		try {
			factory = DocumentBuilderFactory.newInstance();
			DocumentBuilder builder = factory.newDocumentBuilder();
			elanDoc = builder.newDocument();
			annot_doc = elanDoc.createElement("ANNOTATION_DOCUMENT");
			elanDoc.appendChild(annot_doc);
		} catch(Exception e){
			e.printStackTrace();
		}
	}

	//Conversion du fichier TEI vers Elan
	@Override
	public void conversion(){
		// TODO Auto-generated method stub
		//Construction de l'en-tête
		buildHeader();
		//Construction des types linguistiques
		buildLgqTypes();
		//Construction des tiers
		buildTiers();
		//Ajout des types linguistiques
		addLgqTypes();
		//Construction des contraintes Elan
		buildConstraints();
		//Construction des vocabulaires contrôlés
		buildControlledVocabularies();
	}

	//Information contenues dans l'élément annotation_doc et dans l'élément header
	public void buildHeader(){
		annot_doc.setAttribute("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
		annot_doc.setAttribute("xsi:noNamespaceSchemaLocation", "http://www.mpi.nl/tools/elan/EAFv2.8.xsd");
		Element header = elanDoc.createElement("HEADER");
		//date
		String date = "";
		try {
			date = (String)tf.xpath.compile("//appInfo/date/text()").evaluate(tf.teiDoc, XPathConstants.STRING);
		} catch(Exception e) {
			date = "";
		}
		if (date.isEmpty())
			date = new SimpleDateFormat("yyyy-MM-dd:HH:mm:ss").format(Calendar.getInstance().getTime());
		annot_doc.setAttribute("DATE", date);
		annot_doc.setAttribute("AUTHOR", "TEI_CORPO Converter");
		annot_doc.setAttribute("FORMAT", "2.8");
		annot_doc.setAttribute("VERSION", "2.8");
		annot_doc.appendChild(header);
		buildHeaderElement(header);
		//Element timeleine
		Element time_order = elanDoc.createElement("TIME_ORDER");
		annot_doc.appendChild(time_order);
		buildTimeline(time_order);
	}

	//Complétion des informations du header
	void buildHeaderElement(Element header){
		try {
			//Attribut de ANNOTATION_DOCUMENT
			Element teiHeader = (Element) tf.teiDoc.getElementsByTagName("teiHeader").item(0);
	/*
			Element app = (Element)teiHeader.getElementsByTagName("application/appInfo").item(0);
			annot_doc.setAttribute("FORMAT", app.getAttribute("version"));
			annot_doc.setAttribute("VERSION", app.getAttribute("version"));
	*/
			//Mise à jour du header
			//Attributs
			//media_file + elements media
			//besoin units et time
	        XPathExpression expr = tf.xpath.compile("//recordingStmt/recording/media");
	        NodeList medias = (NodeList) expr.evaluate(tf.teiDoc, XPathConstants.NODESET);
			if (medias.getLength()>0) {
				header.setAttribute("MEDIA_FILE", "");
				header.setAttribute("TIME_UNITS", "milliseconds");
				for(int i = 0; i<medias.getLength(); i++) {
					Element elt = (Element)medias.item(i);
					String url = elt.getAttribute("url");
					String mimeType = elt.getAttribute("mimeType");
					File mediaFile = new File(url);
					String mediaName = mediaFile.getName();
					Element eafMedia = elanDoc.createElement("MEDIA_DESCRIPTOR");
					eafMedia.setAttribute("MEDIA_URL", url);
					eafMedia.setAttribute("MIME_TYPE", mimeType);
					eafMedia.setAttribute("RELATIVE_MEDIA_URL", "./" + mediaName);
					header.appendChild(eafMedia);
				}
			}
			//properties : notes additionnelles
			NodeList notes = teiHeader.getElementsByTagName("note");
			for(int j = 0; j<notes.getLength(); j++){
				Element note = (Element) notes.item(j);
				if(note.getAttribute("type").equals("COMMENTS_DESC")){
					NodeList propertyNotes = note.getElementsByTagName("note");
					for(int y = 0; y<propertyNotes.getLength(); y++){
						Element propertyNote = (Element) propertyNotes.item(y);
						Element property = elanDoc.createElement("PROPERTY");
						property.setAttribute("NAME", propertyNote.getAttribute("type"));
						property.setTextContent(propertyNote.getTextContent());
						header.appendChild(property);
					}
				}
			}
		} catch(Exception e) {
			System.err.println("erreur dans le traitement du header");
		}
	}

	//Remplissage de la timeline à partir de la timeline au format TEI : copie exacte: mêmes identifiants et valeurs
	void buildTimeline(Element time_order){
		try {
			//besoin units et time
	        XPathExpression expr = tf.xpath.compile("/TEI/text/timeline/when");
	        NodeList nodes = (NodeList) expr.evaluate(tf.teiDoc, XPathConstants.NODESET);
			String prev_time_units = (String)tf.xpath.compile("/TEI/text/timeline/@unit").evaluate(tf.teiDoc, XPathConstants.STRING);
			double ratio = 1.0;
			String time_units;
			if (prev_time_units.equals("s")) {
				ratio = 1000.0;
				time_units = "milliseconds";
			} else if (prev_time_units.equals("ms")) {
				ratio = 1.0;
				time_units = "milliseconds";
			} else {
				ratio = -1.0;
				System.err.println("unité inconnue pour la timeline: " + prev_time_units + " pas de réajustement");
				time_units = prev_time_units;
			}
			Element header = (Element) annot_doc.getElementsByTagName("HEADER").item(0);
			header.setAttribute("TIME_UNITS", time_units);
			for(int i = 0; i<nodes.getLength(); i++){
				Element when = (Element)nodes.item(i);
				if(when.hasAttribute("interval")){
					String id = when.getAttribute("xml:id");
					String val = when.getAttribute("interval");
					Element time_slot = elanDoc.createElement("TIME_SLOT");
					time_slot.setAttribute("TIME_SLOT_ID", id);
					if (ratio < 0.0)
						time_slot.setAttribute("TIME_VALUE", val);
					else if (!val.isEmpty()) {
						double vald;
						try {
							vald = Double.parseDouble(val);
							vald *= ratio;
							time_slot.setAttribute("TIME_VALUE", Integer.toString((int)vald));
						} catch (Exception e) {
							System.err.println("not a double: " + val);
						}
					}
					time_order.appendChild(time_slot);
				} else if (when.hasAttribute("absolute")) {
					String id = when.getAttribute("xml:id");
					// here we should decode absolute
					// but it is not functional right now
					String val = when.getAttribute("absolute");
					Element time_slot = elanDoc.createElement("TIME_SLOT");
					time_slot.setAttribute("TIME_SLOT_ID", id);
					if (ratio < 0.0)
						time_slot.setAttribute("TIME_VALUE", val);
					else {
						time_slot.setAttribute("TIME_VALUE", "0");
						/* -- waiting for bug sold in value of absolute
						if (!val.isEmpty()) {
							double vald;
							try {
								vald = Double.parseDouble(val);
								vald *= ratio;
								time_slot.setAttribute("TIME_VALUE", Integer.toString((int)vald));
							} catch (Exception e) {
								System.err.println("not a double: " + val);
							}
						}
						*/
					}
					time_order.appendChild(time_slot);
				}
			}
		} catch(Exception e) {
			e.printStackTrace();
			System.err.println("ERREUR dans le traitement de la timeline: " + e.toString());
		}
	}

	//Elements linguistic_type
	void buildLgqTypes(){
		lgqTypes = new ArrayList<Element>();
		tierInfos= new ArrayList<TierInfo>();
		Element teiHeader = (Element) tf.teiDoc.getElementsByTagName("teiHeader").item(0);
		NodeList notes = teiHeader.getElementsByTagName("note");
		for(int j = 0; j<notes.getLength(); j++){
			Element note = (Element) notes.item(j);
			if(note.getAttribute("type").equals("TEMPLATE_DESC")){
				//System.out.println("trouvé les notes TEMPLATE");
				NodeList templateChildren = note.getChildNodes();
				for(int y = 0; y<templateChildren.getLength(); y++){
					TierInfo ti = new TierInfo();
					Element lgqType = elanDoc.createElement("LINGUISTIC_TYPE");
					Node nd = templateChildren.item(y);
					if (!nd.getNodeName().equals("note")) continue;
					NodeList templateNote  = nd.getChildNodes();
					for(int z = 0; z < templateNote.getLength(); z++){
						Node nd2  = templateNote.item(z);
						if (!nd2.getNodeName().equals("note")) continue;
						Element elt = (Element)nd2;
						if(elt.getAttribute("type").equals("code")){
							ti.tier_id = elt.getTextContent();
						}
						else if(elt.getAttribute("type").equals("graphicsref")){
							lgqType.setAttribute("GRAPHIC_REFERENCES", elt.getTextContent());
							ti.type.graphic_ref = elt.getTextContent();
						}
						else if(elt.getAttribute("type").equals("parent")){
							ti.parent = elt.getTextContent();
						}
						else if(elt.getAttribute("type").equals("type")){
							lgqType.setAttribute( "CONSTRAINTS", elt.getTextContent());
							if (elt.getTextContent().equals(LgqType.ROOT) || elt.getTextContent().equals(LgqType.TIME_DIV) || elt.getTextContent().equals(LgqType.INCLUDED))
								lgqType.setAttribute( "TIME_ALIGNABLE", "true");
							else
								lgqType.setAttribute( "TIME_ALIGNABLE", "false");
							ti.type.constraint = elt.getTextContent();
						}
						else if(elt.getAttribute("type").equals("subtype")){
							lgqType.setAttribute( "LINGUISTIC_TYPE_ID", elt.getTextContent());
							ti.type.lgq_type_id = elt.getTextContent();
						}
						else if(elt.getAttribute("type").equals("lang")){
							ti.lang = elt.getTextContent();
						}
						else if(elt.getAttribute("type").equals("cv_id")){
							lgqType.setAttribute( "CONTROLLED_VOCABULARY_REF", elt.getTextContent().substring(1));
							ti.type.cv_ref =  elt.getTextContent().substring(1);
						}
					}
//					System.out.println(ti.toString());
//					System.out.println(lgqType.getAttribute("LINGUISTIC_TYPE_REF"));
					tierInfos.add(ti);
					lgqTypes.add(lgqType);
					//annot_doc.appendChild(lgqType);
				}
			}
		}
		getParticipantNames();
	}

	//Récupération des noms des participants
	void getParticipantNames (){
		NodeList participantsInfo = tf.teiDoc.getElementsByTagName("person");
		for(int i = 0; i<participantsInfo.getLength(); i++){
			Element person = (Element)participantsInfo.item(i);
			for(int j = 0; j<person.getChildNodes().getLength(); j++){
				if(Utils.isElement(person.getChildNodes().item(j))){
					Element child = (Element)person.getChildNodes().item(j);
					if(child.getNodeName().equals("altGrp")){
						for(int z = 0; z<child.getElementsByTagName("alt").getLength(); z++){
							Element alt = (Element) child.getElementsByTagName("alt").item(z);
							if(alt.hasAttribute("type")){
								for(TierInfo ti : tierInfos){
									if(ti.type.lgq_type_id.equals(alt.getAttribute("type"))){
										if(person.getElementsByTagName("persName").getLength()>0){
											ti.participant = person.getElementsByTagName("persName").item(0).getTextContent();
										}
										else{
											ti.participant = "";
										}
									}
								}
							}
						}
					}
				}
			}
		}

	}

	//Ajout des types linguistiques
	void addLgqTypes(){
		for(Element lgqType : lgqTypes){
			if(lgqType.hasAttribute("LINGUISTIC_TYPE_ID")){
				annot_doc.appendChild(lgqType);
			}
		}
	}

	//Elements constraint : toujours les mêmes dans les fichiers Elan
	void buildConstraints(){
		Element constraintTimeDiv = elanDoc.createElement("CONSTRAINT");
		constraintTimeDiv.setAttribute("DESCRIPTION", "Time subdivision of parent annotation's time interval, no time gaps allowed within this interval");
		constraintTimeDiv.setAttribute("STEREOTYPE", "Time_Subdivision");
		Element constraintSymbDiv = elanDoc.createElement("CONSTRAINT");
		constraintSymbDiv.setAttribute("DESCRIPTION", "Symbolic subdivision of a parent annotation. Annotations refering to the same parent are ordered");
		constraintSymbDiv.setAttribute("STEREOTYPE", "Symbolic_Subdivision");
		Element constraintSymbAssoc = elanDoc.createElement("CONSTRAINT");
		constraintSymbAssoc.setAttribute("DESCRIPTION", "1-1 association with a parent annotation");
		constraintSymbAssoc.setAttribute("STEREOTYPE", "Symbolic_Association");
		Element constraintInclIn = elanDoc.createElement("CONSTRAINT");
		constraintInclIn.setAttribute("DESCRIPTION", "Time alignable annotations within the parent annotation's time interval, gaps are allowed");
		constraintInclIn.setAttribute("STEREOTYPE", "Included_In");
		annot_doc.appendChild(constraintTimeDiv);
		annot_doc.appendChild(constraintSymbDiv);
		annot_doc.appendChild(constraintSymbAssoc);
		annot_doc.appendChild(constraintInclIn);
	}

	//Reconstruction du vocabulaire contrôlé
	void buildControlledVocabularies(){
		if(tf.teiDoc.getElementsByTagName("textClass").getLength()>0){
			Element textClass = (Element) tf.teiDoc.getElementsByTagName("textClass").item(0);
			NodeList keywordsList = textClass.getElementsByTagName("keywords");
			for(int i = 0; i<keywordsList.getLength(); i++){
				Element keywords = (Element) keywordsList.item(i);
				Element controlled_voc = elanDoc.createElement("CONTROLLED_VOCABULARY");
				controlled_voc.setAttribute("CV_ID", keywords.getAttribute("scheme"));
				controlled_voc.setAttribute("DESCRIPTION", keywords.getAttribute("type"));
				NodeList terms = keywords.getElementsByTagName("term");
				for(int j = 0; j<terms.getLength(); j++){
					Element term = (Element)terms.item(j);
					Element cve = elanDoc.createElement("CV_ENTRY_ML");
					cve.setAttribute("CVE_ID", term.getAttribute("type"));
					cve.setAttribute("DESCRIPTION", term.getTextContent());
					cve.setAttribute("LANG_REF", term.getAttribute("xml:lang"));
					controlled_voc.appendChild(cve);
				}
				annot_doc.appendChild(controlled_voc);
			}
		}
	}

	//Construction d'une structure intermédiaire contenant les annotations de la transcription
	//Structure = map
	//Clé = Nom du tier
	//Valeur = liste des annotations de ce type
	public HashMap<String, ArrayList<Annot>> getTiers(){
		HashMap<String, ArrayList<Annot>> tiers = new HashMap<String, ArrayList<Annot>>();
		NodeList annotationGrps = null;
		try {
			annotationGrps = Utils.getAllAnnotationBloc(tf.xpath, tf.teiDoc);
		} catch (XPathExpressionException e) {
			System.out.println("Erreur de traitement de xpath annotationBloc");
			e.printStackTrace();
			System.exit(1);
		}
		String type;
		for(int i = 0; i<annotationGrps.getLength(); i++){
			if(Utils.isElement(annotationGrps.item(i))){
				Element annotGrp = (Element) annotationGrps.item(i);
				type = annotGrp.getAttribute("who");
				NodeList annotGrpElmts = annotGrp.getChildNodes();
				for(int j = 0; j<annotGrpElmts.getLength(); j++){
					if(Utils.isElement(annotGrpElmts.item(j))){
						Element annotElmt = (Element)annotGrpElmts.item(j);
						if(annotElmt.getNodeName().equals("u")){
							Annot annot = new Annot();
							annot.content = annotElmt.getTextContent();
							annot.start = annotGrp.getAttribute("start").substring(1);
							annot.end = annotGrp.getAttribute("end").substring(1);
							annot.id = annotGrp.getAttribute("xml:id");
							annot.type = "time";
							addElementToMap(tiers, type, annot);
						}
						else if(annotElmt.getNodeName().equals("spanGrp")){
							spanGrpCase(tiers, annotElmt);
						}
					}
				}
			}
		}
		return tiers;
	}

	//Traitement des spanGrp pour ajout dans la structure Map
	public void spanGrpCase(HashMap<String, ArrayList<Annot>> tiers, Element spanGrp){
		NodeList spans = spanGrp.getElementsByTagName("span");
		String type = spanGrp.getAttribute("type");
		for(int z =0; z<spans.getLength(); z++){
			Element span = (Element) spans.item(z);
			Annot annot = new Annot();
			if(span.getChildNodes().getLength()>0){
				annot.content = span.getChildNodes().item(0).getTextContent();
			}
			annot.id = span.getAttribute("xml:id");					
			if(span.hasAttribute("target")){
				annot.type = "ref";
				annot.link = span.getAttribute("target").substring(1);
			}
			else{
				annot.type = "time";
				if(Utils.isNotEmptyOrNull(annot.start)){
					annot.start = span.getAttribute("from").substring(1);
				}
				if(Utils.isNotEmptyOrNull(annot.end)){
					annot.end = span.getAttribute("to").substring(1);
				}
			}
			addElementToMap(tiers, type, annot);
			if((span.getElementsByTagName("spanGrp").getLength()>0)){
				NodeList spanGrps = span.getElementsByTagName("spanGrp");
				for(int l = 0; l<spanGrps.getLength(); l++){
					Element subSpanGrp = (Element)spanGrps.item(l);
					spanGrpCase(tiers, subSpanGrp);
				}
			}			
		}
	}

	//Tiers...
	void buildTiers(){
		HashMap<String, ArrayList<Annot>> tiers = getTiers();
		for(Map.Entry<String, ArrayList<Annot>> entry: tiers.entrySet()){
			Element tier = elanDoc.createElement("TIER");
			String type = entry.getKey();
			tier.setAttribute("TIER_ID", type);
			setTierAtt(tier,type);
			this.annot_doc.appendChild(tier);
			for(Annot a : entry.getValue()){
				Element annot = elanDoc.createElement("ANNOTATION");
				if(a.type.equals("time")){
					Element align_annot = elanDoc.createElement("ALIGNABLE_ANNOTATION");
					align_annot.setAttribute("ANNOTATION_ID", a.id);
					align_annot.setAttribute("TIME_SLOT_REF1", a.start);
					align_annot.setAttribute("TIME_SLOT_REF2", a.end);
					annot.appendChild(align_annot);
					Element annotationValue = elanDoc.createElement("ANNOTATION_VALUE");
					annotationValue.setTextContent(a.content);
					align_annot.appendChild(annotationValue);
					annot.appendChild(align_annot);
				}
				else if (a.type.equals("ref")){
					Element ref_annot = elanDoc.createElement("REF_ANNOTATION");
					ref_annot.setAttribute("ANNOTATION_ID", a.id);
					ref_annot.setAttribute("ANNOTATION_REF", a.link);
					annot.appendChild(ref_annot);
					Element annotationValue = elanDoc.createElement("ANNOTATION_VALUE");
					annotationValue.setTextContent(a.content);
					ref_annot.appendChild(annotationValue);
					annot.appendChild(ref_annot);					
				}
				tier.appendChild(annot);
			}
		}
	}

	//Ajout des attributs des élement TIER
	void setTierAtt (Element tier, String type){
		for(TierInfo ti : tierInfos) {
			if(ti.tier_id.equals(type)){
				if(Utils.isNotEmptyOrNull(ti.participant)) tier.setAttribute("PARTICIPANT", ti.participant);
				if(Utils.isNotEmptyOrNull(ti.lang)) tier.setAttribute("DEFAULT_LOCALE", ti.lang);
				if(Utils.isNotEmptyOrNull(ti.annotator)) tier.setAttribute("ANNOTATOR", ti.annotator);
				if(Utils.isNotEmptyOrNull(ti.lang_ref)) tier.setAttribute("LANG_REF", ti.lang_ref);
				if(Utils.isNotEmptyOrNull(ti.parent)) tier.setAttribute("PARENT_REF", ti.parent);
				if(Utils.isNotEmptyOrNull(ti.type.lgq_type_id)) tier.setAttribute("LINGUISTIC_TYPE_REF", ti.type.lgq_type_id);
			}
		}
	}

	void addElementToMap(HashMap<String, ArrayList<Annot>> map, String type, Annot annot){
		if(map.containsKey(type)){
			map.get(type).add(annot);
		}
		else{
			ArrayList<Annot> newAnnotList = new ArrayList<Annot>();
			newAnnotList.add(annot);
			map.put(type, newAnnotList);
		}
	}

	// Création du fichier de sortie
	public void createOutput() {
		Source source = new DOMSource(elanDoc);
		Result resultat = new StreamResult(outputName);

		try {
			TransformerFactory fabrique2 = TransformerFactory.newInstance();
			Transformer transformer = fabrique2.newTransformer();
			transformer.setOutputProperty(OutputKeys.INDENT, "yes");
			transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");
			transformer.transform(source, resultat);
		} catch(Exception e){
			e.printStackTrace();
		}
	}

	public static void usage() {
		System.err.println("Description: TeiToElan convertit un fichier au format Tei en un fichier au format Elan");
		System.err.println("Usage: TeiToElan [-options] <file" + Utils.EXT + ">");
		System.err.println("	     :-i nom du fichier ou repertoire où se trouvent les fichiers Tei à convertir (les fichiers ont pour extension " + Utils.EXT);
		System.err.println("	     :-o nom du fichier de sortie au format Elan (.eaf) ou du repertoire de résultats");
		System.err.println("	     	si cette option n'est pas spécifié, le fichier de sortie aura le même nom que le fichier d'entrée avec l'extension .eaf;");
		System.err.println("	     	si on donne un repertoire comme input et que cette option n'est pas spécifiée, les résultats seront stockés dans le même dossier que l'entrée.\"");
		System.err.println("	     :-usage ou -help = affichage ce message");
		System.exit(1);
	}	

	public static void main(String args[]) throws IOException {
		String input = null;
		String output = null;
		//Parcours des arguments
		if (args.length == 0) {
			System.err.println("Vous n'avez spécifié aucun argument\n");
			usage();
		} else {
			for (int i = 0; i < args.length; i++) {
				try {
					if (args[i].equals("-i")) {
						i++;
						input = args[i];
					} else if (args[i].equals("-o")) {
						i++;
						output = args[i];
					} else {
						usage();
					}
				} catch (Exception e) {
					usage();
				}
			}
		}
		File f = new File(input);
		//Permet d'avoir le nom complet du fichier (chemin absolu, sans signes spéciaux(. et .. par ex))
		input = f.getCanonicalPath();
		if (f.isDirectory()){
			File[] teiFiles = f.listFiles();

			String outputDir = "";
			if (output == null){
				if(input.endsWith("/")){
					outputDir = input.substring(0, input.length()-1);
				}
				else{
					outputDir = input + "/";
				}
			}
			else{
				outputDir = output;
				if(!outputDir.endsWith("/")){
					outputDir = output + "/";
				}
			}
			File outFile = new File(outputDir);
			if(outFile.exists()){
				if(!outFile.isDirectory()){
					System.out.println("\n Erreur :"+ output + " est un fichier, vous devez spécifier un nom de dossier pour le stockage des résultats. \n");
					usage();
					System.exit(1);
				}
			}
			new File(outputDir).mkdir();
			for (File file : teiFiles){
				String name = file.getName();
				if (file.isFile() && (name.endsWith(Utils.EXT))){
					String outputFileName = file.getName().split("\\.")[0] + Utils.EXT_PUBLISH + EXT;
					TeiToElan tte = new TeiToElan(file.getAbsolutePath(), outputDir+outputFileName);
					System.out.println(outputDir+outputFileName);
					tte.createOutput();
				}
				else if(file.isDirectory()){
					args[0] = "-i";
					args[1] = file.getAbsolutePath();
					main(args);
				}
			}
		}
		else{
			if (output == null) {
				output = input.split("\\.")[0] + Utils.EXT_PUBLISH + EXT;
			}
			else if(new File(output).isDirectory()){
				if(output.endsWith("/")){
					output = output + input.split("\\.")[0] + Utils.EXT_PUBLISH + EXT;
				}
				else{
					output = output + "/"+ input.split("\\.")[0] + Utils.EXT_PUBLISH + EXT;
				}
			}

			if (!Utils.validFileFormat(input, Utils.EXT)) {
				System.err.println("Le fichier d'entrée du programme doit avoir l'extension" + Utils.EXT);
				usage();
			}
			TeiToElan tte = new TeiToElan(new File(input).getAbsolutePath(), output);
			System.out.println("Reading " + input);
			tte.createOutput();
			System.out.println("New file created " + output);
		}
	}
}
